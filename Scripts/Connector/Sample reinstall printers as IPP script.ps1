# The script is meant to help customers resintall Connector printers using Ipp Directed Discovery.
# It can be run in the same Connector or in a new one.

# The scripts requires a text file with the format:
#   cloudDeviceId1 => ipAddress1
#   cloudDeviceId2 => ipAddress2
#   cloudDeviceId3 => ipAddress3
#   ...
# This can be generated by running the script "Sample list printers for reinstallation script.ps1" on the old Connector host machine.

# For each printer in the file, the script will try reinstalling it using Ipp Directed Discovery, registering it with the Connector,
# and swaping the printers underneath the UP share.

# RUN THIS SCRIPT IN AN ELEVATED POWERSHELL WINDOW
#Requires -RunAsAdministrator

#
# Helper functions
#

# Install the required module by running Install-Module "Microsoft.Identity.Client"
#Requires -Modules "Microsoft.Identity.Client"

# Install the required module by running Install-Module "UniversalPrintManagement"
#Requires -Modules "UniversalPrintManagement"

Import-Module "Microsoft.Identity.Client"

function Get-ConnectorServiceUri 
{
    $servicePort = Get-ItemPropertyValue -path HKLM:SOFTWARE\Microsoft\UniversalPrint\Connector -Name ServicePort
    $uri = "http://localhost:$servicePort/WindowsServiceHostedService/PrinterConnectorService?wsdl"
    return $uri;
}

function Get-PublicClientApplication
{
    # Universal Print Connector's client id to retrieve an AAD authentication token
    $ClientId = "80331ee5-4436-4815-883e-93bc833a9a15"
    $Authority = "https://login.microsoftonline.com/common"
    $RedirectUri = "https://UniversalPrintConnector"
    $pcaConfig = [Microsoft.Identity.Client.PublicClientApplicationBuilder]::Create($ClientId).WithAuthority($Authority).WithRedirectUri($RedirectUri)
    return $pcaConfig.Build();
}

function Register-LocalPrinterWithUP($ConnectorService, $PrinterName, $Token)
{
    Write-Host Registering printer $PrinterName

    $result = $false
    $resultSpecified = $false
    $ConnectorService.RegisterPrinter($printerName, $null, "printer", $Token, [ref] $result, [ref] $resultSpecified)
    if ($result)
    {
        Write-Host "Successfully registered printer $PrinterName"
    }
    else
    {
        Write-Error "Failed to register $PrinterName printer. Please check the Event Viewer Log for details."
    }
}

function GetNameOfInstalledPrinters ()
{
    $installedPrinters = @{}
    Get-ChildItem 'HKLM:\SYSTEM\CurrentControlSet\Control\Print\Printers' | ForEach-Object {
        $installedPrinters.add($_.PSChildName, "true")
    }
    return $installedPrinters
}


#
# Main
#

Write-Host "ReinstallPrintersAsIpp v1.0."
$file_path = Read-Host "Please enter file name with the printers you wish to reinstall using IPP "
$verify = Read-Host "Do you want the script to pause before swapping each printer to verify it has the capabilities you need? (y/n)"

# Sign in to UP
Connect-UPService

# Ensure Connector is registered
$ConnectorServiceUri = Get-ConnectorServiceUri
$ConnectorService = New-WebServiceProxy -Uri $ConnectorServiceUri -UseDefaultCredential
$isConnectorRegistered = $false;
$isConnectorRegisteredSpecified = $false;
$ConnectorService.IsConnectorRegistered([ref] $isConnectorRegistered, [ref] $isConnectorRegisteredSpecified)
if (!$isConnectorRegistered)
{
    Write-Error "Connector needs to be registered first. Please use the Print Connector App to register the Connector." -ErrorAction Stop
}

# IPP Directed Discovery does not currenlty allow to pass in the name we want to give to the printer
# so we need to idenitfy the newly installed printers by their V4 Dir
$newV4DirToUpPrinter = @{}

#
# Go through the file and reinstall the printers using Ipp Directed discovery
#
try {
    Get-Content -Path $file_path | ForEach-Object {
        
        if ([string]::IsNullOrWhiteSpace($_))
        {
            # Skip empty lines
            continue
        }

        Write-Host "`r`nProcessing new printer from file..." -ForegroundColor Blue
        Write-Host "    Entry: " $_

        try
        {
            # Extract printer id and ipp url
            $elements = [regex]::Split($_, "=>")
            $oldPrinter_id = $elements[0] -replace " ", ""
            $printer_url = $elements[1] -replace " ", ""
            Write-Host "    Cloud Device Id: " $oldPrinter_id
            Write-Host "    Ipp Url: " $printer_url

            # Get the name and share id from UP
            $oldPrinter = Get-UPPrinter -PrinterId $oldPrinter_id
            Write-Host "    Name: " $oldPrinter.Results.DisplayName
            
            # Try to install the printer through IPP Directed Discovery
            Write-Host "    Installing printer through Ipp"

            # Name will be ignored but some OS versions request it anyways
            Add-Printer -IppURL $printer_url -Name $oldPrinter.Results.DisplayName -ErrorAction Stop
	        Write-Host "    Completed installation" 

            # From the V4 dirs, get the last added printer to map it to the printer we are replacing
            Write-Host "    Track new printer"
            $v4Dirs = Get-ChildItem "C:\Windows\System32\spool\V4Dirs" | Sort-Object CreationTime -Descending
            $newV4DirToUpPrinter.add($v4Dirs[0].Name, $oldPrinter)
	
	        Write-Host "    Completed"
        } 
        catch 
        {
            Write-Warning "Failed to reinstall printer: $_"
        }
    }
}
catch
{
    Write-Warning "Caught exception while reinstalling the printers: $_"
}

$printersToSwap = @{}
#
# Go through the recently installed printers to restore the names
#
Write-Host "`r`n----- Register IPP printers with UP  -----`r`n"
$installedPrinters = GetNameOfInstalledPrinters
foreach ($printer in $installedPrinters.GetEnumerator())
{
    $RegKeyName = "Registry::HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Print\Printers\$($printer.Name)"
    $valueName = "PrintQueueV4DriverDirectory"
    if (Test-Path -LiteralPath $RegKeyName) {
        $v4Dir = Get-ItemProperty -LiteralPath $RegKeyName -Name $valueName -ErrorAction SilentlyContinue
        if ($v4Dir -and $newV4DirToUpPrinter.ContainsKey($v4Dir.$valueName))
        {
            # Get the printer we are swapping
            $oldPrinter = $newV4DirToUpPrinter[$v4Dir.$valueName]
            
            # Rename the new printer
            $newPrinter_name = $oldPrinter.Results.DisplayName + "_ipp"
            Rename-Printer -Name $printer.Name -NewName $newPrinter_name
            Write-Host "`r`nRestore printer name " $printer.Name " => " $newPrinter_name

            $printersToSwap.add($newPrinter_name, $oldPrinter)
        }
    }
}

#
# Get things ready to register new printers with UP
#
$publicClientApplication = Get-PublicClientApplication
$account = $null
$scope = "https://print.print.microsoft.com/.default";
$scopes = New-Object System.Collections.Generic.List[string]
$scopes.Add($scope)

"# Run this script to unregister old UP printers" | Out-File -FilePath cleanup.ps1
"# Run this script to swap back to the non-IPP printers" | Out-File -FilePath revert.ps1

Write-Host "`r`n----- Register and swap IPP printers  -----`r`n"
foreach ($printer in $printersToSwap.GetEnumerator())
{
    $newPrinter_name = $printer.Name
    $oldPrinter = $printer.Value

    # Check the printer setting to decide if you want to proceed registering and swapping the printers
    if ($verify -ne "n")
    {
        Write-Host "Open the printer settings of " $newPrinter_name " to verify the capabilities that will be available."
        $proceed = Read-Host "Do you want to proceed with registration and swap? (y/n)"
        if ($proceed -eq "n")
        {
            Write-Host "Printer won't be registered."
            continue
        }
    }

    Write-Host "Ensuring a valid AAD authentication token exists"
    if ($account -ne $null)
    {
        $authResult = $publicClientApplication.AcquireTokenSilent($scopes, $account).ExecuteAsync().Result
    }
    # If we don't have a valid account or if the silent call fails, get the token interactively
    if ($authResult -eq $null)
    {
        $authResult = $publicClientApplication.AcquireTokenInteractive($scopes).ExecuteAsync().Result
    }
    # Cache the account for subsequent usage
    $account = $authResult.Account
    
    # Register the printer with the Connector
    Register-LocalPrinterWithUP -ConnectorService $ConnectorService -PrinterName $newPrinter_name -Token $authResult.AccessToken

    # Get the new printer id
    $CloudDataKey = "Registry::HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Print\Printers\$($newPrinter_name)\CloudData"
    $newPrinter_cloudData = Get-ItemProperty -LiteralPath $CloudDataKey -ErrorAction SilentlyContinue
    $newPrinter_id = $newPrinter_cloudData.CloudDeviceId
    Write-Host "`r`nCloudDeviceID of ipp printer: $newPrinter_id"

    # Switch the share
    Set-UPPrinterShare -Id $oldPrinter.Results.Shares.Id -TargetPrinterId $newPrinter_id

    # Append to cleanup file
    "Remove-UPPrinter -PrinterId $($oldPrinter.Results.Id) -Confirm:`$false" | Out-File -FilePath cleanup.ps1 -Append
    
    # Append to revert file
    "Set-UPPrinterShare -Id $($oldPrinter.Results.Shares.Id) -TargetPrinterId $($oldPrinter.Results.Id)" | Out-File -FilePath revert.ps1 -Append
}

Write-Host "`r`nThe script has completed."
Write-Host "File cleanup.ps1 has been written to the current directory and can be used to unregister the old UP printers."
Write-Host "File revert.ps1 has been written to the current directory and can be used to swap back to the non-Ipp printers."